# C: Системное погружение и структуры данных

Этот курс подготовит вас к созданию **GitFlow Dashboard**, раскрывая механизмы работы ОС и ручного построения сложных систем.

---

## Модуль 1: Связные списки (Linked Lists)

**Важность:** CRITICAL
**Время на изучение:** ~25 минут

### 1. Концепт (The Concept)
Массив — это "плитка", где все ячейки лежат в ряд. Но если мы не знаем, сколько будет коммитов в GitHub, нам нужна структура, которая может бесконечно расти.

**Связный список** — это цепочка "узлов" (Nodes). Каждый узел хранит:
1.  **Data:** Сами данные (например, заголовок коммита).
2.  **Next:** Указатель (адрес) на следующий узел в цепочке.

*Ментальная модель:*
```text
[ Data | Netx ] -> [ Data | Next ] -> [ Data | NULL ]
      Node 1             Node 2             Конец
```
Преимущество: Мы можем вставить новый узел в любое место, просто перебросив указатели.

### 2. Синтаксис (The Code)
Используем `malloc` для создания узлов в Куче (Heap).

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next; // Самореференсная структура
} Node;

void print_list(Node *head) {
    Node *current = head;
    while (current != NULL) {
        printf("[%d] -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

int main() {
    // 1. Создаем первый узел
    Node *head = malloc(sizeof(Node));
    head->data = 10;
    head->next = NULL;

    // 2. Добавляем второй узел
    Node *second = malloc(sizeof(Node));
    second->data = 20;
    second->next = NULL;
    head->next = second; // Связываем их

    print_list(head);

    // 3. Не забываем очистку (упрощенно)
    free(second);
    free(head);
    
    return 0;
}
```

### 3. Минное поле (The Trap)
**Потеря головы (Memory Leak & Lost Head).**
Если вы сделаете `head = head->next`, не сохранив адрес первого узла, вы больше никогда не сможете его вызвать или сделать `free()`. Память будет занята "призраком".

*Всегда используйте временный указатель `current` для обхода списка!*

### 4. Микро-Задача (Micro-Task)
Напишите программу `list_push.c`.

1.  Создайте функцию `void push(Node **head, int value)`, которая добавляет новый узел в **начало** списка.
2.  **Почему `**head`?** Чтобы функция могла изменить адрес самого указателя head в `main`.
3.  В `main` добавьте числа 5, 10, 15 через `push` и выведите список. Должно получиться: `[15] -> [10] -> [5] -> NULL`.

---

## Модуль 2: Управление процессами (Syscalls & Fork)

**Важность:** CRITICAL (Основа Демона)
**Время на изучение:** ~30 минут

### 1. Концепт (The Concept)
Когда вы запускаете программу, ОС создает **Процесс**. 
Системный вызов — это "просьба" к ядру ОС: "Эй, Линукс, сделай что-то, что я сам не могу" (например, создай новый процесс).

Главный вызов для демонов — `fork()`.
Он делает **полную копию** текущего процесса. С этого момента у вас две одинаковых программы, бегущих одновременно.
- **Родитель (Parent):** Получает от `fork()` PID (ID процесса) ребенка.
- **Ребенок (Child):** Получает от `fork()` цифру 0.

Так мы можем сказать ребенку: "Иди в фон и качай GitHub", а родителю: "Завершай работу, чтобы пользователь снова увидел командную строку".

### 2. Синтаксис (The Code)
Используем `<unistd.h>`.

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        return 1;
    }

    if (pid == 0) {
        // Мы в процессе-ребенке
        printf("I am the CHILD! My PID is %d. My Dad is %d\n", getpid(), getppid());
    } else {
        // Мы в процессе-родителе
        printf("I am the PARENT! My child has PID %d\n", pid);
    }

    return 0;
}
```

### 3. Минное поле (The Trap)
**Fork-бомба.**
Если вы вызовете `fork()` внутри бесконечного цикла, вы создадите тысячи процессов, пока компьютер не зависнет.
*Будьте очень осторожны с `fork()` внутри циклов!*

### 4. Микро-Задача (Micro-Task)
Напишите программу `daemon_start.c`.

1.  Вызовите `fork()`.
2.  Если вы — **Родитель**: Выведите "Starting daemon..." и сразу сделайте `exit(0)`.
3.  Если вы — **Ребенок**:
    - Подождите 5 секунд (`sleep(5)`).
    - Создайте файл `daemon.txt` и запишите туда "I am alive!".
    - Завершитесь.
4.  Запустите программу и убедитесь, что консоль освободилась мгновенно, а файл появился через 5 секунд. Это — ваш первый шаг к настоящему демону!
