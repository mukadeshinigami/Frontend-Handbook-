# C: Быстрый старт через практику

## Модуль 1: Анатомия памяти

**Важность:** CRITICAL
**Время на изучение:** ~15 минут

### 1. Концепт (The Concept)
Память (RAM) — это не магия, а просто гигантский массив пронумерованных ячеек (байт). Каждая ячейка имеет свой уникальный адрес (например, `0x7fff5fbff8ac`).

Когда вы объявляете переменную, вы просто "бронируете" несколько подряд идущих ячеек.

*Ментальная модель:*

```text
      Адрес       Значение      Переменная
+----------------+---------+    
| 0x7ffd00000000 |   ??    |    <-- Мусор (Garbage)
+----------------+---------+
| 0x7ffd00000004 |   10    |    int a; (4 байта)
| 0x7ffd00000005 |   ..    |
| 0x7ffd00000006 |   ..    |
| 0x7ffd00000007 |   00    |
+----------------+---------+
| 0x7ffd00000008 |   'F'   |    char c; (1 байт)
+----------------+---------+
```

**Stack (Стек):** Область памяти для локальных переменных.
- **Быстрая:** Выделение памяти = просто сдвиг указателя стека.
- **Грязная:** В новой переменной лежит *мусор* (то, что было в этой ячейке раньше), пока вы явно не запишете туда значение.

### 2. Синтаксис (The Code)
Стандарт C11. Проверка размера типов.

```c
#include <stdio.h>
#include <limits.h> // Для констант INT_MAX и т.д.

int main(void) {
    // 1. Объявление (Allocating on Stack)
    // ВНИМАНИЕ: Без инициализации здесь был бы мусор!
    int age = 25;       
    char grade = 'A';
    float pi = 3.14f;

    // 2. Оператор sizeof (Compile-time оператор, не функция!)
    // Возвращает размер в байтах.
    printf("Type Sizes (in bytes):\n");
    printf("char:  %zu\n", sizeof(char));   // Всегда 1
    printf("int:   %zu\n", sizeof(int));    // Обычно 4 (зависит от архитектуры)
    printf("float: %zu\n", sizeof(float));  // Обычно 4
    
    // Показать адрес в памяти (где физически лежит переменная)
    // %p - спецификатор для указателя (pointer)
    printf("\nAddresses (Location in RAM):\n");
    printf("Address of age:   %p\n", (void*)&age);
    printf("Address of grade: %p\n", (void*)&grade);

    return 0;
}
```

### 3. Минное поле (The Trap)
**Использование неинициализированной памяти.**
В Python/JS переменные имеют значения по умолчанию или `undefined`. В C переменная имеет значение "то, что лежало в этом байте с прошлого раза".

```c
#include <stdio.h>

int main(void) {
    int secret_key; // <--- ОПАСНОСТЬ! Мы не присвоили значение.
    
    // Мы читаем мусор из стека. Это может быть 0, а может быть пароль от WiFi 
    // из предыдущей функции (условно).
    printf("My secret key is: %d\n", secret_key); 
    
    // UB (Undefined Behavior): Поведение программы не определено стандартом.
    // Может работать, может упасть, может вызвать демона.
    return 0;
}
```

### 4. Микро-Задача (Micro-Task)
Напишите программу `memory_dump.c`.

1.  Объявите переменные: `int x = 42`, `char c = 'Z'`, `short s = 777`.
2.  Выведите на экран их **размеры** (`sizeof`) и **адреса** (`&x`, `&c`, `&s`).
3.  **Эксперимент:** Посмотрите на адреса. Они идут подряд? С каким шагом? (Обратите внимание, что `int` занимает 4 байта, а `short` - 2).

*Подсказка:* Для вывода адреса используйте `%p` и приведение `(void*)&var`. 


***

## Модуль 2: Указатели (Часть 1) — Введение

**Важность:** CRITICAL
**Время на изучение:** ~20 минут

### 1. Концепт (The Concept)
Указатель (Pointer) — это просто переменная, которая хранит **адрес** другой переменной.
Это не магия. Это просто `unsigned long` (на 64-битных системах), который мы интерпретируем как "номер квартиры" в памяти.

Зачем? Чтобы передавать данные "без копирования" и менять оригиналы из других функций.

*Ментальная модель:*

```text
Переменная    Адрес           Значение
--------------------------------------
int a         0x100           42
int *p        0x104           0x100  <-- p "указывает" на a
```

Если мы скажем "иди по адресу, записанному в Code `p`, и положи туда 99", то изменится значение `a`.

### 2. Синтаксис (The Code)

Два главных оператора:
1.  `&` (Address-of): Взять адрес переменной. "Где ты живешь?"
2.  `*` (Dereference): Иди по адресу. "Постучи в дверь и дай мне то, что внутри".

```c
#include <stdio.h>

int main(void) {
    int original = 100;
    
    // 1. Создаем указатель
    // "int *" читается как "указатель на int"
    int *ptr = &original; 
    
    printf("Value of original: %d\n", original); // 100
    printf("Address of original: %p\n", (void*)&original); 
    printf("Value of ptr: %p\n", (void*)ptr);    // Тот же адрес
    
    // 2. Разыменование (Dereference)
    // Изменяем original ЧЕРЕЗ ptr
    *ptr = 200; 
    
    printf("New value of original: %d\n", original); // 200 (Magic!)
    
    return 0;
}
```

### 3. Минное поле (The Trap)
**Segfault (Segmentation Fault):** Попытка доступа к памяти, которая вам не принадлежит.

Самая частая причина: **Разыменование NULL или мусорного указателя.**

```c
#include <stdio.h>

int main(void) {
    int *ptr = NULL; // Указатель в "никуда" (адрес 0x0)
    
    // Хорошая практика: всегда проверять на NULL
    if (ptr != NULL) {
        *ptr = 50;
    } else {
        printf("Safety net: ptr is NULL\n");
    }

    // ПЛОХО:
    // *ptr = 100; // <--- CRASH! Программа упадет с Segmentation fault.
    // Операционная система видит попытку записи в 0x0 и убивает процесс.
    
    return 0;
}
```

### 4. Микро-Задача (Micro-Task)
Напишите программу `swap_pointers.c`.

1.  Создайте две переменные `int a = 10`, `int b = 20`.
2.  Напишите код, который меняет значения `a` и `b` местами, **используя только указатели** `ptrA` и `ptrB`.
3.  Нельзя использовать `a = ...` или `b = ...` в логике обмена. Только `*ptrA` и `*ptrB`.

*Подсказка:* Вам понадобится временная переменная `int temp`.


***

## Модуль 3: Адресная арифметика

**Важность:** CRITICAL
**Время на изучение:** ~25 минут

### 1. Концепт (The Concept)
Массив в С — это **ложь**. Это просто указатель на первый элемент блока памяти.

Самое важное правило С: **`ptr + 1` увеличивает адрес не на 1 байт, а на `sizeof(тип)` байт.**
Если `int` занимает 4 байта, то `int_ptr + 1` перепрыгнет сразу на 4 байта вперед (к следующему целому числу).

*Ментальная модель:*

`int arr[3] = {10, 20, 30};`

```text
Index:      0       1       2
Value:    [ 10 ]  [ 20 ]  [ 30 ]
Address:  0x100   0x104   0x108
            ^       ^       ^
Ptr:        p      p+1     p+2
```

### 2. Синтаксис (The Code)
Доступ к массиву через квадратные скобки `[]` — это просто "синтаксический сахар".
`arr[i]` компилятор превращает в `*(arr + i)`.

```c
#include <stdio.h>

int main(void) {
    int numbers[] = {10, 20, 30, 40, 50};
    
    // Имя массива = адрес его начала
    int *ptr = numbers; 

    printf("Start address: %p\n", (void*)ptr);
    
    // Арифметика
    printf("First element: %d\n", *ptr);       // 10
    printf("Second element: %d\n", *(ptr + 1)); // 20
    
    // Альтернативная запись (суть та же)
    printf("Third element: %d\n", ptr[2]);      // 30
    
    return 0;
}
```

### 3. Минное поле (The Trap)
**Buffer Overflow (Выход за границы массива).**
С не проверяет границы (потому что это медленно). Если вы попросите элемент №100 в массиве из 5 элементов, С послушно прочитает (или запишет!) память далеко за пределами массива.

Это причина 90% уязвимостей в ПО.

```c
#include <stdio.h>

int main(void) {
    int arr[3] = {1, 2, 3};
    
    // ОШИБКА: Индексы 0, 1, 2. Мы лезем в 3.
    // Мы читаем память СРАЗУ ПОСЛЕ массива. Там может лежать адрес возврата из функции.
    printf("OOPS: %d\n", arr[3]); 
    
    // А вот это может сломать программу (перезапись чужой памяти):
    // arr[1000] = 999; <--- Segfault
    
    return 0;
}
```

### 4. Микро-Задача (Micro-Task)
Напишите программу `ptr_traversal.c`.

1.  Создайте массив `long values[] = {100, 200, 300}`.
2.  Используя указатель `long *p`, пройдите в цикле `for` по массиву и выведите значения.
3.  **Условие:** В цикле **нельзя** использовать индексы (`values[i]`).
    Используйте инкремент указателя: `p++` (сдвинуть указатель на следующий элемент).

*Код для старта:*
```c
long values[] = {100, 200, 300};
long *p = values;
for (int i = 0; i < 3; i++) {
    // Ваш код здесь: вывести *p, затем сдвинуть p
}
```


***

## Модуль 4: Строки в С (Опасная зона)

**Важность:** CRITICAL
**Время на изучение:** ~20 минут

### 1. Концепт (The Concept)
В С **нет типа string**.
Строка — это просто массив `char`, в конце которого **обязан** стоять нулевой байт `\0` (число 0, не символ '0').

Это "сигнальный огонь", который говорит функциям вроде `printf`: "Стоп! Дальше текст кончился, там мусор".

*Ментальная модель:* `char s[] = "Hi!";`

```text
Index:      0       1       2       3
Value:    ['H']   ['i']   ['!']   [\0]  <-- Terminator
Hex:       0x48    0x69    0x21    0x00
```
Размер массива: 4 байта (3 символа + 1 нуль-терминатор).

### 2. Синтаксис (The Code)
Литералы строк (`"text"`) автоматически добавляют `\0`. Ручные массивы — нет.

```c
#include <stdio.h>

int main(void) {
    // Вариант 1: Литерал (Read-only memory!)
    // Попытка изменить *str1 = 'X' вызовет Segfault на многих платформах.
    char *str1 = "Hello"; 
    
    // Вариант 2: Массив (Stack memory)
    // Можно менять: str2[0] = 'X' работает.
    char str2[] = "World"; 
    
    printf("%s %s\n", str1, str2);
    
    // Как на самом деле выглядит конец строки
    // Эквивалент: char manual[] = {'C', 'o', 'd', 'e', '\0'};
    
    return 0;
}
```

### 3. Минное поле (The Trap)
**The Off-by-One Error (Ошибка на единицу).**
Забыть место под `\0`.

```c
#include <stdio.h>

int main(void) {
    // ОШИБКА: "Hello" это 5 букв + 1 ноль = 6 байт.
    // Мы выделили только 5. Нуль-терминатор не влезает.
    char buf[5] = "Hello"; 
    
    // printf будет читать память ДАЛЬШЕ buf, пока случайно не встретит 0.
    // Вывод может быть: "Hello@#$@! garbage..."
    printf("Broken string: %s\n", buf); 
    
    return 0;
}
```

### 4. Микро-Задача (Micro-Task)
Напишите программу `my_strlen.c`.

1.  Напишите функцию `int my_len(char *s)`, которая считает длину строки.
2.  **Запрещено** использовать `<string.h>` и `strlen`.
3.  Логика: Создайте цикл, который идет по указателю `s` (`while (*s != ...)`), пока не встретит нуль-терминатор.
4.  В `main` протестируйте её на строке "C Programming". Должно вернуть 13.

Помните: сам нуль-терминатор в длину строки не входит!


***

## Модуль 5: Функции и Стек

**Важность:** HIGH
**Время на изучение:** ~20 минут

### 1. Концепт (The Concept)
Когда вы вызываете функцию, С **копирует** аргументы.
Если вы передаете `int x`, функция получает **копию** `x`. Изменение копии не влияет на оригинал.

Чтобы изменить оригинал, нужно передать **адрес** оригинала (указатель).

*Ментальная модель (Stack Frame):*
Вызов `func(a)` создает новый "слой" в стеке.

```text
Stack (Растет вниз)
+----------------+
| main() frame   |  int a = 10;
+----------------+
| func() frame   |  int copy_of_a = 10;
+----------------+
```
Когда `func` завершается, её фрейм уничтожается (память освобождается).

### 2. Синтаксис (The Code)

```c
#include <stdio.h>

// Pass by Value (Копия)
void try_change(int val) {
    val = 999; // Меняет локальную копию
}

// Pass by Reference (Адрес)
void real_change(int *ptr) {
    *ptr = 999; // Идет по адресу и меняет память main-а
}

int main(void) {
    int x = 10;
    
    try_change(x);
    printf("After try_change: %d\n", x); // 10 (Ничего не случилось)
    
    real_change(&x); // Передаем АДРЕС
    printf("After real_change: %d\n", x); // 999 (Успех)
    
    return 0;
}
```

### 3. Минное поле (The Trap)
**Возврат адреса локальной переменной.**
Никогда не возвращайте указатель на переменную, созданную внутри функции (на стеке). Как только функция завершится, эта память станет "мусором".

```c
int* bad_function() {
    int local_var = 42;
    return &local_var; // ОШИБКА! local_var уничтожится при возврате.
}
// Caller получит указатель на "трупа".
```

### 4. Микро-Задача (Micro-Task)
Напишите программу `stack_test.c`.

1.  Напишите функцию `void power_up(int *hp, int amount)`, которая увеличивает здоровье игрока (`hp`) на `amount`.
2.  В `main` создайте `int player_health = 100`.
3.  Вызовите `power_up`, передав адрес здоровья и бонус (+50).
4.  Выведите результат. Должно быть 150.


***

## Модуль 6: Структуры (Struct)

**Важность:** CRITICAL
**Время на изучение:** ~25 минут

### 1. Концепт (The Concept)
Структура — это способ сгруппировать разные переменные в **один непрерывный блок памяти**.

Но есть подвох: **Alignment (Выравнивание)**.
Процессор не любит читать данные с произвольных адресов. Ему нравится читать по 4 или 8 байт (слова). Если вы положите `char` (1 байт) перед `int` (4 байта), компилятор вставит "пустоту" (padding), чтобы `int` начался с красивого адреса, кратного 4.

*Ментальная модель:* `struct { char c; int i; };`

```text
Address:  | 0x00 | 0x01 | 0x02 | 0x03 | 0x04 . . . 0x07 |
Content:  | [c]  | PADDING (Мусор)    | [  i (4 bytes)  ] |
```
Итоговый размер: 8 байт (а не 1+4=5).

### 2. Синтаксис (The Code)
Используем `typedef`, чтобы не писать слово `struct` каждый раз.

```c
#include <stdio.h>
#include <string.h>

// Создаем "чертеж"
typedef struct {
    char name[10];
    int age;
} Person;

int main(void) {
    // Выделяем память (на стеке)
    Person p;
    
    // Доступ через точку (.)
    p.age = 30;
    // p.name = "Alice"; // ОШИБКА! Массив нельзя присвоить.
    strcpy(p.name, "Alice"); // Надо копировать байты.

    printf("Name: %s, Age: %d\n", p.name, p.age);
    
    // Доступ через указатель (->)
    Person *ptr = &p;
    ptr->age = 31; // То же самое, что (*ptr).age
    
    printf("New Age: %d\n", ptr->age);

    return 0;
}
```

### 3. Минное поле (The Trap)
**Padding bloat (Раздувание структуры).**
Порядок полей имеет значение!

```c
struct Bad {
    char c1;  // 1 байт + 3 padding
    int i;    // 4 байта
    char c2;  // 1 байт + 3 padding
}; // Size: 12 bytes

struct Good {
    int i;    // 4 байта
    char c1;  // 1 байт
    char c2;  // 1 байт + 2 padding (чтобы вся структура была кратна 4)
}; // Size: 8 bytes
```

### 4. Микро-Задача (Micro-Task)
Напишите программу `struct_size.c`.

1.  Объявите две структуры с одинаковыми полями, но разным порядком:
    *   `struct A { char c; double d; char b; };`
    *   `struct B { double d; char c; char b; };`
2.  Выведите `sizeof(struct A)` и `sizeof(struct B)`.
3.  Удивитесь разнице (обычно `double` требует выравнивания по 8 байт).


***

## Модуль 7: Динамическая память (Heap)

**Важность:** CRITICAL
**Время на изучение:** ~30 минут

### 1. Концепт (The Concept)
Стек (Stack) мал и живет недолго. Если вам нужно сохранить миллион записей или вернуть большой массив из функции, вам нужен **Heap (Куча)**.

Heap — это "дикий запад".
1.  Вы сами просите память (`malloc`).
2.  Вы сами возвращаете её системе (`free`).
3.  Если забыли вернуть — память "утекает" (Memory Leak), пока компьютер не зависнет.

*Ментальная модель:*

```text
Stack (Акуратная стопка)        Heap (Большой склад)
|  [ptr]  | ----------------->  | [ Block of Memory ] |
```

### 2. Синтаксис (The Code)
Библиотека `<stdlib.h>`.
`void* malloc(size_t size)` — возвращает указатель на сырую память.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int n = 5;
    
    // 1. Просим память для n целых чисел
    // (int*) - приведение типа (в C++ обязательно, в C нет, но полезно для ясности)
    int *arr = (int*)malloc(n * sizeof(int));
    
    // 2. ВСЕГДА проверяем, дали ли нам память
    if (arr == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }
    
    // 3. Работаем как с обычным массивом
    for (int i = 0; i < n; i++) {
        arr[i] = i * 10;
        printf("%d ", arr[i]);
    }
    
    // 4. Уборка (Garbage Collection в ручном режиме)
    free(arr);
    arr = NULL; // Хорошая практика: занулить указатель, чтобы случайно не использовать снова.
    
    return 0;
}
```

### 3. Минное поле (The Trap)
**Memory Leaks & Double Free.**

1.  **Leak:** Выделили память в цикле и не освободили.
2.  **Double Free:** Дважды вызвали `free` на один адрес -> Crash программы.
3.  **Use After Free:** Использовать указатель после `free`.

```c
void leak_memory() {
    void *p = malloc(1024);
    // ... функция закончилась, p исчез (со стека), а 1024 байта в куче остались заняты НАВСЕГДА (до рестарта программы).
}
```

### 4. Микро-Задача (Micro-Task)
Напишите программу `dynamic_string.c`.

1.  Запросите у пользователя длину будущей строки (`scanf`).
2.  Выделите память ровно под этот размер + 1 байт (под `\0`).
3.  Запросите саму строку (`scanf("%s", str)` или `fgets`).
4.  Выведите строку в обратном порядке.
5.  **Освободите память.**

*Финал:* Запустите программу с Valgrind (если есть Linux) или просто перепроверьте код трижды: `malloc` есть? `free` есть?

---
**Курс завершен.** Вы прошли путь от битов до ручного управления памятью. Теперь вы готовы к ядрам, драйверам и высокопроизводительному коду.



