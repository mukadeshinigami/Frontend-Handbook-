# Блок 2: Типы данных и операторы

## Цель

Понять типы данных C, их размеры и диапазоны значений, а также освоить все операторы языка: арифметические, логические, побитовые и операторы сравнения.

---

## 1. Целочисленные типы

### Типы и их размеры

Размер типов в C может варьироваться в зависимости от архитектуры (32-битная или 64-битная система), но стандарт определяет минимальные требования:

| Тип | Минимальный размер | Типичный размер (64-bit) | Диапазон (типичный) |
|-----|-------------------|--------------------------|---------------------|
| `char` | 8 бит | 8 бит | -128 до 127 (signed) или 0 до 255 (unsigned) |
| `short` | 16 бит | 16 бит | -32,768 до 32,767 |
| `int` | 16 бит | 32 бита | -2,147,483,648 до 2,147,483,647 |
| `long` | 32 бита | 64 бита (Linux) или 32 (Windows) | ±2.1×10⁹ или ±9.2×10¹⁸ |
| `long long` | 64 бита | 64 бита | ±9.2×10¹⁸ |

**Важно:** Размеры не фиксированы стандартом, только минимальные требования!

### Определение размеров типов

Используйте `sizeof()` для проверки размеров на вашей системе:

```c
#include <stdio.h>
#include <limits.h>

int main(void) {
    printf("Size of char: %zu bytes\n", sizeof(char));
    printf("Size of short: %zu bytes\n", sizeof(short));
    printf("Size of int: %zu bytes\n", sizeof(int));
    printf("Size of long: %zu bytes\n", sizeof(long));
    printf("Size of long long: %zu bytes\n", sizeof(long long));
    
    return 0;
}
```

**`%zu`** — спецификатор для типа `size_t` (тип возвращаемого значения `sizeof()`).

### Модификаторы: signed и unsigned

По умолчанию целые типы — знаковые (`signed`), но можно явно указать:

```c
signed int x = -100;        // Знаковое (может быть отрицательным)
unsigned int y = 100;       // Беззнаковое (только положительные)
unsigned int z = -1;        // ❌ Ошибка или неопределённое поведение

// char - особый случай: может быть signed или unsigned (зависит от компилятора)
signed char c1 = -128;
unsigned char c2 = 255;
```

### Диапазоны значений

Для проверки минимальных и максимальных значений используйте заголовочный файл `<limits.h>`:

```c
#include <stdio.h>
#include <limits.h>

int main(void) {
    printf("INT_MIN = %d\n", INT_MIN);
    printf("INT_MAX = %d\n", INT_MAX);
    printf("UINT_MAX = %u\n", UINT_MAX);
    printf("LONG_MIN = %ld\n", LONG_MIN);
    printf("LONG_MAX = %ld\n", LONG_MAX);
    
    return 0;
}
```

### Литералы и суффиксы

```c
int decimal = 42;              // Десятичное число
int octal = 052;               // Восьмеричное (начинается с 0)
int hex = 0x2A;                // Шестнадцатеричное (0x или 0X)

long big = 1000000L;           // Суффикс L для long
long long huge = 1000000LL;    // Суффикс LL для long long

unsigned int u = 100U;         // Суффикс U для unsigned
unsigned long ul = 100UL;      // Комбинация: unsigned long
unsigned long long ull = 100ULL; // unsigned long long
```

**Разделители для читаемости (C23):**
```c
int million = 1'000'000;  // C23 (не все компиляторы поддерживают)
int million_old = 1000000; // Старый способ
```

---

## 2. Вещественные типы (floating-point)

### Типы с плавающей точкой

| Тип | Размер | Точность | Диапазон (примерно) |
|-----|--------|----------|---------------------|
| `float` | 32 бита | ~7 значащих цифр | ±3.4×10³⁸ |
| `double` | 64 бита | ~15-17 значащих цифр | ±1.7×10³⁰⁸ |
| `long double` | ≥64 бита | ≥double | Зависит от платформы |

### Литералы с плавающей точкой

```c
float f1 = 3.14f;           // Суффикс f или F для float
float f2 = 3.14F;

double d1 = 3.14;           // По умолчанию double
double d2 = 3.14;           // Без суффикса

long double ld = 3.14L;     // Суффикс L для long double

// Научная нотация
double scientific = 1.23e4;     // 12300.0
double small = 1.23e-4;         // 0.000123
```

### Точность и округление

```c
#include <stdio.h>
#include <float.h>

int main(void) {
    printf("FLT_DIG = %d\n", FLT_DIG);         // Точность float
    printf("DBL_DIG = %d\n", DBL_DIG);         // Точность double
    printf("LDBL_DIG = %d\n", LDBL_DIG);       // Точность long double
    
    float f = 0.1f + 0.2f;
    printf("0.1 + 0.2 = %.10f\n", f);  // Может быть 0.3000000119
    // ⚠️ Вещественные числа могут иметь ошибки округления!
    
    return 0;
}
```

---

## 3. Арифметические операторы

### Базовые операции

```c
#include <stdio.h>

int main(void) {
    int a = 10, b = 3;
    
    printf("%d + %d = %d\n", a, b, a + b);   // Сложение: 13
    printf("%d - %d = %d\n", a, b, a - b);   // Вычитание: 7
    printf("%d * %d = %d\n", a, b, a * b);   // Умножение: 30
    printf("%d / %d = %d\n", a, b, a / b);   // Деление: 3 (целочисленное!)
    printf("%d %% %d = %d\n", a, b, a % b);  // Остаток: 1
    
    // Для вещественного деления
    float x = 10.0f, y = 3.0f;
    printf("%.2f / %.2f = %.2f\n", x, y, x / y); // 3.33
    
    return 0;
}
```

### Целочисленное деление

⚠️ **Важно:** Деление целых чисел — целочисленное (остаток отбрасывается):

```c
int result1 = 10 / 3;      // 3 (не 3.33!)
int result2 = 10 / 4;      // 2 (не 2.5!)

// Для вещественного результата нужно вещественное деление:
float result3 = 10.0f / 3.0f;  // 3.33...
```

### Остаток от деления (%)

Оператор `%` возвращает остаток от деления:

```c
int remainder1 = 10 % 3;   // 1 (10 = 3*3 + 1)
int remainder2 = 10 % 4;   // 2 (10 = 4*2 + 2)
int remainder3 = 10 % 5;   // 0 (10 = 5*2 + 0)

// ⚠️ Остаток от деления отрицательных чисел зависит от реализации!
int r1 = -10 % 3;          // Может быть -1 или 2
```

### Переполнение

```c
int max = INT_MAX;
printf("INT_MAX = %d\n", max);
printf("INT_MAX + 1 = %d\n", max + 1);  // ⚠️ Переполнение! Неопределённое поведение

unsigned int u_max = UINT_MAX;
printf("UINT_MAX = %u\n", u_max);
printf("UINT_MAX + 1 = %u\n", u_max + 1);  // Обёртывается к 0 (определено для unsigned)
```

---

## 4. Операторы присваивания

### Простое присваивание

```c
int x = 5;        // Инициализация
x = 10;           // Присваивание
```

### Составные операторы присваивания

```c
int x = 10;

x += 5;   // x = x + 5  → 15
x -= 3;   // x = x - 3  → 12
x *= 2;   // x = x * 2  → 24
x /= 4;   // x = x / 4  → 6
x %= 4;   // x = x % 4  → 2

// Также работают для побитовых операций (см. ниже)
x &= 3;   // x = x & 3
x |= 4;   // x = x | 4
x ^= 5;   // x = x ^ 5
x <<= 1;  // x = x << 1
x >>= 1;  // x = x >> 1
```

---

## 5. Инкремент и декремент

### Префиксные операторы

Увеличивают/уменьшают значение, затем возвращают новое значение:

```c
int x = 5;
int y = ++x;      // x становится 6, y = 6

int a = 5;
int b = --a;      // a становится 4, b = 4
```

### Постфиксные операторы

Возвращают текущее значение, затем увеличивают/уменьшают:

```c
int x = 5;
int y = x++;      // y = 5, затем x становится 6

int a = 5;
int b = a--;      // b = 5, затем a становится 4
```

### Примеры использования

```c
#include <stdio.h>

int main(void) {
    int x = 5;
    
    printf("x = %d\n", x);           // 5
    printf("++x = %d\n", ++x);       // 6 (x теперь 6)
    printf("x = %d\n", x);           // 6
    printf("x++ = %d\n", x++);       // 6 (x становится 7)
    printf("x = %d\n", x);           // 7
    
    // Использование в циклах (будет в следующем уроке)
    for (int i = 0; i < 5; i++) {    // Постфиксный инкремент
        printf("%d ", i);
    }
    // Вывод: 0 1 2 3 4
    
    return 0;
}
```

### ⚠️ Избегайте множественных изменений одной переменной

```c
int x = 5;
int y = ++x + x++;  // ⚠️ Неопределённое поведение! Не делайте так!
```

---

## 6. Операторы сравнения

### Операторы сравнения

Возвращают `1` (true) или `0` (false):

```c
#include <stdio.h>

int main(void) {
    int a = 5, b = 10;
    
    printf("%d == %d: %d\n", a, b, a == b);  // Равно: 0 (false)
    printf("%d != %d: %d\n", a, b, a != b);  // Не равно: 1 (true)
    printf("%d < %d: %d\n", a, b, a < b);    // Меньше: 1 (true)
    printf("%d > %d: %d\n", a, b, a > b);    // Больше: 0 (false)
    printf("%d <= %d: %d\n", a, b, a <= b);  // Меньше или равно: 1
    printf("%d >= %d: %d\n", a, b, a >= b);  // Больше или равно: 0
    
    return 0;
}
```

### ⚠️ Частая ошибка: `=` вместо `==`

```c
int x = 5;

// ❌ ОШИБКА: присваивание вместо сравнения
if (x = 10) {  // Всегда true! x становится 10
    printf("x is 10\n");
}

// ✅ ПРАВИЛЬНО: сравнение
if (x == 10) {
    printf("x is 10\n");
}

// Хорошая практика: сравнивать константу слева (компилятор предупредит)
if (10 == x) {  // Если напишете =, будет ошибка компиляции
    printf("x is 10\n");
}
```

---

## 7. Логические операторы

### Логическое И (&&)

Возвращает `1` (true), если оба операнда истинны:

```c
int a = 5, b = 10;

if (a > 0 && b > 0) {        // true (оба > 0)
    printf("Both positive\n");
}

// Короткое замыкание (short-circuit evaluation)
if (a != 0 && 10 / a > 2) {  // Если a == 0, деление не выполнится
    printf("Safe division\n");
}
```

### Логическое ИЛИ (||)

Возвращает `1` (true), если хотя бы один операнд истинен:

```c
int age = 25;

if (age < 18 || age > 65) {
    printf("Special category\n");
}

// Короткое замыкание
if (ptr == NULL || *ptr == 0) {  // Если ptr == NULL, разыменование не выполнится
    printf("Safe access\n");
}
```

### Логическое НЕ (!)

Инвертирует значение:

```c
int flag = 0;

if (!flag) {          // true (flag == 0)
    printf("Flag is false\n");
}

if (!!flag) {         // false (двойное отрицание)
    printf("This won't print\n");
}
```

### Таблица истинности

| A | B | A && B | A \|\| B | !A |
|---|---|--------|---------|-----|
| 0 | 0 | 0 | 0 | 1 |
| 0 | 1 | 0 | 1 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 1 | 1 | 1 | 0 |

---

## 8. Побитовые операторы

Побитовые операторы работают с отдельными битами чисел. Полезны для низкоуровневого программирования.

### Побитовое И (&)

Результат — `1` только если оба бита равны `1`:

```c
unsigned int a = 0b1100;  // 12 в двоичном
unsigned int b = 0b1010;  // 10 в двоичном
unsigned int result = a & b;  // 0b1000 (8)

// 1100
// 1010
// ----
// 1000
```

### Побитовое ИЛИ (|)

Результат — `1` если хотя бы один бит равен `1`:

```c
unsigned int a = 0b1100;  // 12
unsigned int b = 0b1010;  // 10
unsigned int result = a | b;  // 0b1110 (14)

// 1100
// 1010
// ----
// 1110
```

### Побитовое исключающее ИЛИ (^)

Результат — `1` если биты различны:

```c
unsigned int a = 0b1100;  // 12
unsigned int b = 0b1010;  // 10
unsigned int result = a ^ b;  // 0b0110 (6)

// 1100
// 1010
// ----
// 0110
```

**Интересное свойство:** `a ^ a = 0` и `a ^ 0 = a`

### Побитовое НЕ (~)

Инвертирует все биты:

```c
unsigned char a = 0b00001111;  // 15
unsigned char result = ~a;     // 0b11110000 (240)

// Для signed типов результат зависит от представления чисел
```

### Сдвиг влево (<<)

Сдвигает биты влево, заполняя справа нулями. Эквивалентно умножению на 2:

```c
unsigned int a = 5;        // 0b101
unsigned int result = a << 1;  // 0b1010 (10) - умножение на 2
unsigned int result2 = a << 2; // 0b10100 (20) - умножение на 4

// a << n эквивалентно a * (2^n)
```

### Сдвиг вправо (>>)

Сдвигает биты вправо:

```c
unsigned int a = 20;       // 0b10100
unsigned int result = a >> 1;  // 0b1010 (10) - деление на 2
unsigned int result2 = a >> 2; // 0b101 (5) - деление на 4

// a >> n эквивалентно a / (2^n) для unsigned
```

⚠️ **Для signed типов:** поведение сдвига вправо зависит от реализации (арифметический или логический сдвиг).

### Практические примеры побитовых операций

```c
#include <stdio.h>

// Установить бит в позиции pos
unsigned int set_bit(unsigned int num, int pos) {
    return num | (1U << pos);
}

// Очистить бит в позиции pos
unsigned int clear_bit(unsigned int num, int pos) {
    return num & ~(1U << pos);
}

// Переключить бит в позиции pos
unsigned int toggle_bit(unsigned int num, int pos) {
    return num ^ (1U << pos);
}

// Проверить, установлен ли бит
int is_bit_set(unsigned int num, int pos) {
    return (num >> pos) & 1U;
}

int main(void) {
    unsigned int x = 0b1010;  // 10
    
    printf("Original: %u (0b1010)\n", x);
    
    x = set_bit(x, 2);
    printf("After set bit 2: %u (0b1110)\n", x);
    
    x = clear_bit(x, 1);
    printf("After clear bit 1: %u (0b1100)\n", x);
    
    x = toggle_bit(x, 0);
    printf("After toggle bit 0: %u (0b1101)\n", x);
    
    printf("Bit 3 is set: %d\n", is_bit_set(x, 3));
    
    return 0;
}
```

---

## 9. Приоритет операторов

Операторы выполняются в определённом порядке. Если порядок не очевиден, используйте скобки!

### Таблица приоритетов (по убыванию)

| Приоритет | Операторы | Ассоциативность |
|-----------|-----------|-----------------|
| 1 (высший) | `()` `[]` `.` `->` `++` `--` (постфиксные) | Слева направо |
| 2 | `++` `--` (префиксные) `+` `-` (унарные) `!` `~` `*` (разыменование) `&` (адрес) `sizeof` `(type)` | Справа налево |
| 3 | `*` `/` `%` | Слева направо |
| 4 | `+` `-` (бинарные) | Слева направо |
| 5 | `<<` `>>` | Слева направо |
| 6 | `<` `<=` `>` `>=` | Слева направо |
| 7 | `==` `!=` | Слева направо |
| 8 | `&` (побитовое) | Слева направо |
| 9 | `^` | Слева направо |
| 10 | `\|` | Слева направо |
| 11 | `&&` | Слева направо |
| 12 | `\|\|` | Слева направо |
| 13 | `?:` (тернарный) | Справа налево |
| 14 | `=` `+=` `-=` `*=` `/=` `%=` `<<=` `>>=` `&=` `^=` `\|=` | Справа налево |
| 15 (низший) | `,` | Слева направо |

### Примеры

```c
int a = 2, b = 3, c = 4;

int result1 = a + b * c;        // 2 + (3 * 4) = 14 (не 20!)
int result2 = (a + b) * c;      // (2 + 3) * 4 = 20

int result3 = a << 2 + 1;       // a << (2 + 1) = 2 << 3 = 16 (не 10!)
int result4 = (a << 2) + 1;     // (2 << 2) + 1 = 8 + 1 = 9

// Лучше использовать скобки для ясности!
int result5 = (a > 0) && (b < 10) || (c == 4);  // Неясный приоритет
int result6 = ((a > 0) && (b < 10)) || (c == 4); // Явный приоритет
```

---

## 10. Тернарный оператор

Условный оператор: `condition ? value_if_true : value_if_false`

```c
#include <stdio.h>

int main(void) {
    int a = 5, b = 10;
    
    // Найти максимум
    int max = (a > b) ? a : b;
    printf("Max of %d and %d is %d\n", a, b, max);
    
    // Абсолютное значение
    int x = -5;
    int abs_x = (x < 0) ? -x : x;
    printf("Absolute value of %d is %d\n", x, abs_x);
    
    // Вложенные тернарные операторы (осторожно!)
    int score = 85;
    char grade = (score >= 90) ? 'A' : 
                 (score >= 80) ? 'B' : 
                 (score >= 70) ? 'C' : 'F';
    printf("Score %d gets grade %c\n", score, grade);
    
    // Но лучше использовать if-else для сложных условий!
    
    return 0;
}
```

---

## Резюме Блока 2

### Что мы изучили:

✅ Целочисленные типы: `char`, `short`, `int`, `long`, `long long`  
✅ Модификаторы: `signed`, `unsigned`  
✅ Вещественные типы: `float`, `double`, `long double`  
✅ Размеры типов: `sizeof()`  
✅ Литералы и суффиксы (`L`, `UL`, `f`)  
✅ Арифметические операторы: `+`, `-`, `*`, `/`, `%`  
✅ Операторы присваивания: `=`, `+=`, `-=`, `*=`, `/=`, `%=`  
✅ Инкремент и декремент: `++`, `--`  
✅ Операторы сравнения: `==`, `!=`, `<`, `>`, `<=`, `>=`  
✅ Логические операторы: `&&`, `||`, `!`  
✅ Побитовые операторы: `&`, `|`, `^`, `~`, `<<`, `>>`  
✅ Приоритет операторов  
✅ Тернарный оператор: `?:`  

### Следующие шаги:

Переходите к `02-types-operators-practice.md` для выполнения практических заданий!

---

## Полезные ресурсы

- `<limits.h>` — константы для диапазонов целых типов
- `<float.h>` — константы для диапазонов вещественных типов
- [Bitwise Operations (Wikipedia)](https://en.wikipedia.org/wiki/Bitwise_operation)

---

## Типичные ошибки

1. **Целочисленное деление вместо вещественного**
   ```c
   int a = 10, b = 3;
   float result = a / b;  // ❌ 3.0 (не 3.33!)
   float result2 = (float)a / b;  // ✅ 3.33...
   ```

2. **`=` вместо `==`**
   ```c
   if (x = 5) { }  // ❌ Ошибка: присваивание
   if (x == 5) { } // ✅ Правильно: сравнение
   ```

3. **Переполнение**
   ```c
   int max = INT_MAX;
   int overflow = max + 1;  // ⚠️ Неопределённое поведение
   ```

4. **Использование побитовых операторов вместо логических**
   ```c
   if (x & y) { }   // Побитовое И (может работать, но неправильно)
   if (x && y) { }  // ✅ Логическое И (правильно для условий)
   ```

