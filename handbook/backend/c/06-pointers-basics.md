# Блок 6: Указатели (Pointers) — часть 1

## Цель

Понять основы указателей — ключевую концепцию C. Указатели дают прямой доступ к памяти и являются основой для эффективной работы с данными.

---

## 1. Что такое указатель?

**Указатель** — это переменная, которая хранит **адрес** другой переменной в памяти.

### Аналогия

Представьте память как улицу с домами:
- **Переменная** — это дом (значение)
- **Адрес** — это номер дома (где находится значение)
- **Указатель** — это бумажка с номером дома (хранит адрес)

```c
#include <stdio.h>

int main(void) {
    int number = 42;      // Переменная со значением 42
    int* ptr = &number;   // Указатель, хранящий адрес number
    
    printf("Value of number: %d\n", number);      // 42
    printf("Address of number: %p\n", &number);   // Адрес в памяти
    printf("Value of ptr: %p\n", ptr);            // Тот же адрес
    printf("Value at ptr: %d\n", *ptr);           // 42 (разыменование)
    
    return 0;
}
```

---

## 2. Операторы указателей

### Оператор `&` (адрес)

Получает адрес переменной:

```c
int x = 10;
int* ptr = &x;  // ptr хранит адрес переменной x
```

### Оператор `*` (разыменование)

Получает значение по адресу, хранящемуся в указателе:

```c
int x = 10;
int* ptr = &x;

printf("%d\n", *ptr);  // Выводит 10 (значение по адресу)
```

**Важно:** `*` используется в двух контекстах:
1. При объявлении: `int* ptr` — объявляет указатель
2. При использовании: `*ptr` — разыменовывает указатель

---

## 3. Объявление указателей

### Синтаксис

```c
тип* имя_указателя;     // Стиль 1 (тип привязан к *)
тип *имя_указателя;     // Стиль 2 (звёздочка привязана к имени)
тип * имя_указателя;    // Стиль 3 (пробелы с обеих сторон)
```

**Все три стиля эквивалентны!** Выберите один и придерживайтесь его.

```c
#include <stdio.h>

int main(void) {
    int x = 10;
    int y = 20;
    
    // Объявление указателей
    int* ptr1 = &x;  // Указывает на x
    int* ptr2 = &y;  // Указывает на y
    
    printf("x = %d, y = %d\n", x, y);
    printf("ptr1 points to: %d\n", *ptr1);  // 10
    printf("ptr2 points to: %d\n", *ptr2);  // 20
    
    return 0;
}
```

### Указатели разных типов

```c
int* int_ptr;        // Указатель на int
float* float_ptr;    // Указатель на float
char* char_ptr;      // Указатель на char
double* double_ptr;  // Указатель на double
```

**Важно:** Тип указателя должен соответствовать типу переменной, на которую он указывает!

---

## 4. Инициализация указателей

### NULL — пустой указатель

`NULL` означает, что указатель ни на что не указывает:

```c
#include <stdio.h>

int main(void) {
    int* ptr = NULL;  // Указатель не указывает ни на что
    
    // Проверка перед использованием
    if (ptr != NULL) {
        printf("%d\n", *ptr);  // Не выполнится
    } else {
        printf("Pointer is NULL\n");
    }
    
    return 0;
}
```

**⚠️ Всегда инициализируйте указатели!** Неинициализированный указатель содержит "мусор" и может привести к ошибкам.

```c
// ❌ ПЛОХО - неинициализированный указатель
int* ptr;
*ptr = 10;  // ОПАСНО! Может привести к краху программы

// ✅ ХОРОШО - инициализированный указатель
int x = 10;
int* ptr = &x;  // Или ptr = NULL;
```

---

## 5. Разыменование указателей

Разыменование — получение значения по адресу:

```c
#include <stdio.h>

int main(void) {
    int number = 42;
    int* ptr = &number;
    
    printf("number = %d\n", number);    // 42
    printf("*ptr = %d\n", *ptr);        // 42 (то же значение)
    
    // Изменение через указатель
    *ptr = 100;  // Изменяем значение number через указатель
    
    printf("number = %d\n", number);    // 100 (изменилось!)
    printf("*ptr = %d\n", *ptr);        // 100
    
    return 0;
}
```

**Важно:** Изменение значения через указатель изменяет исходную переменную!

---

## 6. Указатели и массивы

Массивы и указатели тесно связаны в C:

```c
#include <stdio.h>

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};
    
    // arr - это указатель на первый элемент
    printf("arr = %p\n", arr);              // Адрес первого элемента
    printf("&arr[0] = %p\n", &arr[0]);      // Тот же адрес!
    
    // Доступ через указатель
    int* ptr = arr;  // ptr указывает на arr[0]
    
    printf("arr[0] = %d\n", arr[0]);        // 10
    printf("*ptr = %d\n", *ptr);            // 10
    printf("*(arr + 0) = %d\n", *(arr + 0)); // 10
    
    // Доступ к другим элементам
    printf("arr[2] = %d\n", arr[2]);        // 30
    printf("*(ptr + 2) = %d\n", *(ptr + 2)); // 30
    printf("ptr[2] = %d\n", ptr[2]);        // 30 (ptr можно использовать как массив!)
    
    return 0;
}
```

**Ключевой момент:** `arr[i]` эквивалентно `*(arr + i)`

---

## 7. Арифметика указателей

С указателями можно выполнять арифметические операции:

```c
#include <stdio.h>

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};
    int* ptr = arr;  // Указывает на arr[0]
    
    printf("ptr points to: %d\n", *ptr);        // 10
    
    ptr++;  // Перемещаемся к следующему элементу
    printf("After ptr++: %d\n", *ptr);          // 20
    
    ptr += 2;  // Перемещаемся на 2 элемента вперёд
    printf("After ptr += 2: %d\n", *ptr);      // 40
    
    ptr--;  // Перемещаемся на 1 элемент назад
    printf("After ptr--: %d\n", *ptr);         // 30
    
    // Разница между указателями
    int* ptr1 = &arr[0];
    int* ptr2 = &arr[3];
    printf("Difference: %ld\n", ptr2 - ptr1);  // 3 (элементов)
    
    return 0;
}
```

**Важно:**
- `ptr++` перемещает указатель на **размер типа** вперёд
- Для `int*` это 4 байта (обычно)
- Для `char*` это 1 байт
- Арифметика работает только в пределах одного массива!

---

## 8. Сравнение указателей

Указатели можно сравнивать:

```c
#include <stdio.h>

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};
    int* ptr1 = &arr[0];
    int* ptr2 = &arr[2];
    int* ptr3 = &arr[0];
    
    // Сравнение адресов
    if (ptr1 < ptr2) {
        printf("ptr1 comes before ptr2\n");
    }
    
    if (ptr1 == ptr3) {
        printf("ptr1 and ptr3 point to the same location\n");
    }
    
    if (ptr1 != ptr2) {
        printf("ptr1 and ptr2 point to different locations\n");
    }
    
    return 0;
}
```

**Важно:** Сравнивать можно только указатели, указывающие на элементы одного массива!

---

## 9. Указатели на указатели

Указатель может указывать на другой указатель:

```c
#include <stdio.h>

int main(void) {
    int x = 42;
    int* ptr = &x;        // Указатель на int
    int** pptr = &ptr;    // Указатель на указатель на int
    
    printf("x = %d\n", x);              // 42
    printf("*ptr = %d\n", *ptr);        // 42
    printf("**pptr = %d\n", **pptr);    // 42
    
    // Изменение через двойной указатель
    **pptr = 100;
    printf("x = %d\n", x);              // 100
    
    return 0;
}
```

**Когда использовать:**
- Передача указателя в функцию для изменения самого указателя
- Многомерные массивы
- Сложные структуры данных

---

## 10. Указатели как параметры функций

Указатели позволяют изменять переменные в вызывающей функции:

```c
#include <stdio.h>

// Передача по значению (не изменяет исходную переменную)
void increment_by_value(int x) {
    x++;  // Изменяется только локальная копия
}

// Передача по указателю (изменяет исходную переменную)
void increment_by_pointer(int* x) {
    (*x)++;  // Изменяет значение по адресу
}

int main(void) {
    int num = 10;
    
    printf("Before: %d\n", num);  // 10
    
    increment_by_value(num);
    printf("After increment_by_value: %d\n", num);  // 10 (не изменилось)
    
    increment_by_pointer(&num);
    printf("After increment_by_pointer: %d\n", num);  // 11 (изменилось!)
    
    return 0;
}
```

### Пример: обмен значений

```c
#include <stdio.h>

// ❌ НЕ РАБОТАЕТ - передача по значению
void swap_wrong(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

// ✅ РАБОТАЕТ - передача по указателю
void swap_correct(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main(void) {
    int x = 10, y = 20;
    
    printf("Before swap: x = %d, y = %d\n", x, y);
    
    swap_wrong(x, y);
    printf("After swap_wrong: x = %d, y = %d\n", x, y);  // Не изменилось
    
    swap_correct(&x, &y);
    printf("After swap_correct: x = %d, y = %d\n", x, y);  // Изменилось!
    
    return 0;
}
```

---

## 11. const и указатели

`const` с указателями создаёт несколько вариантов:

### Указатель на константу

```c
const int* ptr;  // Нельзя изменить значение через указатель
int x = 10;
ptr = &x;
// *ptr = 20;  // ❌ Ошибка компиляции!
```

### Константный указатель

```c
int* const ptr;  // Нельзя изменить сам указатель
int x = 10, y = 20;
ptr = &x;
// ptr = &y;  // ❌ Ошибка компиляции!
*ptr = 30;  // ✅ Можно изменить значение
```

### Константный указатель на константу

```c
const int* const ptr;  // Нельзя изменить ни указатель, ни значение
int x = 10;
ptr = &x;
// ptr = &y;  // ❌ Ошибка
// *ptr = 20; // ❌ Ошибка
```

### Примеры

```c
#include <stdio.h>

int main(void) {
    int x = 10;
    int y = 20;
    
    // Указатель на константу
    const int* ptr1 = &x;
    // *ptr1 = 30;  // ❌ Ошибка: нельзя изменить значение
    ptr1 = &y;      // ✅ Можно изменить указатель
    
    // Константный указатель
    int* const ptr2 = &x;
    *ptr2 = 30;     // ✅ Можно изменить значение
    // ptr2 = &y;   // ❌ Ошибка: нельзя изменить указатель
    
    // Константный указатель на константу
    const int* const ptr3 = &x;
    // *ptr3 = 40;  // ❌ Ошибка
    // ptr3 = &y;   // ❌ Ошибка
    
    return 0;
}
```

**Правило чтения:** Читайте справа налево:
- `const int*` → "указатель на константный int"
- `int* const` → "константный указатель на int"
- `const int* const` → "константный указатель на константный int"

---

## 12. Практические примеры

### Пример 1: Поиск максимума в массиве

```c
#include <stdio.h>

int find_max(int* arr, int size) {
    if (size <= 0) return -1;
    
    int max = arr[0];
    for (int i = 1; i < size; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

int main(void) {
    int numbers[] = {3, 7, 2, 9, 1, 5};
    int size = sizeof(numbers) / sizeof(numbers[0]);
    
    int max = find_max(numbers, size);
    printf("Maximum: %d\n", max);
    
    return 0;
}
```

### Пример 2: Обращение массива

```c
#include <stdio.h>

void reverse_array(int* arr, int size) {
    int* start = arr;
    int* end = arr + size - 1;
    
    while (start < end) {
        // Обмен значений
        int temp = *start;
        *start = *end;
        *end = temp;
        
        start++;
        end--;
    }
}

int main(void) {
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    printf("Before: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    reverse_array(arr, size);
    
    printf("After: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    return 0;
}
```

### Пример 3: Функция, возвращающая указатель

```c
#include <stdio.h>

int* find_element(int* arr, int size, int value) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == value) {
            return &arr[i];  // Возвращаем указатель на найденный элемент
        }
    }
    return NULL;  // Не найдено
}

int main(void) {
    int arr[] = {10, 20, 30, 40, 50};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    int* found = find_element(arr, size, 30);
    if (found != NULL) {
        printf("Found: %d at address %p\n", *found, found);
    } else {
        printf("Not found\n");
    }
    
    return 0;
}
```

---

## Резюме Блока 6

### Что мы изучили:

✅ **Указатели** — переменные, хранящие адреса  
✅ **Операторы** `&` (адрес) и `*` (разыменование)  
✅ **Инициализация** указателей (`NULL`)  
✅ **Арифметика указателей** — перемещение по памяти  
✅ **Указатели и массивы** — тесная связь  
✅ **Указатели как параметры** — передача по ссылке  
✅ **const и указатели** — защита данных  
✅ **Указатели на указатели** — многоуровневая адресация  

### Следующие шаги:

Переходите к `07-pointers-memory.md` для изучения динамической памяти (`malloc`, `free`)!

---

## Типичные ошибки

1. **Использование неинициализированного указателя**
   ```c
   int* ptr;
   *ptr = 10;  // ❌ ОПАСНО! Неопределённое поведение
   ```

2. **Разыменование NULL указателя**
   ```c
   int* ptr = NULL;
   *ptr = 10;  // ❌ Segmentation fault!
   ```

3. **Забыли оператор `&` при передаче в функцию**
   ```c
   void func(int* x) { }
   int num = 10;
   func(num);  // ❌ Нужно func(&num)
   ```

4. **Забыли оператор `*` при разыменовании**
   ```c
   int x = 10;
   int* ptr = &x;
   printf("%d\n", ptr);  // ❌ Выведет адрес, а не значение
   printf("%d\n", *ptr); // ✅ Правильно
   ```

5. **Арифметика указателей вне массива**
   ```c
   int x = 10;
   int* ptr = &x;
   ptr++;  // ❌ ОПАСНО! Указатель вне допустимой области
   ```

---

## Полезные ресурсы

- Указатели — основа эффективного программирования на C
- Понимание указателей критично для работы с памятью
- Практикуйтесь с указателями перед переходом к динамической памяти


